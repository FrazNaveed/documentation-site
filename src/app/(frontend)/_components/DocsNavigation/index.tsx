"use client";
import React from "react";
import * as Accordion from "@radix-ui/react-accordion";
import * as ScrollArea from "@radix-ui/react-scroll-area";
import { ChevronDown } from "lucide-react";
import { useRouter } from "next/navigation";
import styles from "./index.module.scss";

// Sidebar item type definition
interface SidebarItem {
  type: string;
  label?: string;
  collapsed?: boolean;
  link?: {
    type: string;
    id?: string;
    slug?: string;
    description?: string;
  };
  items?: SidebarItem[];
  dirName?: string;
  value?: string;
}

interface SidebarLinkProps {
  href: string;
  className: string;
  children: React.ReactNode;
}

const sidebars = {
  networkSidebar: [
    {
      type: "doc" as "doc",
      label: "Introduction",
      link: { type: "doc", id: "intro" },
    },
    {
      type: "category" as "category",
      label: "Network",
      collapsed: true,
      link: { type: "doc", id: "network/overview" },
      items: [
        {
          type: "doc" as "doc",
          label: "Getting Started",
          link: { type: "doc", id: "network/getting-started" },
        },
        {
          type: "category" as "category",
          label: "Network Guides",
          collapsed: true,
          link: {
            slug: "/category/network/guides",
            type: "generated-index" as "generated-index",
            description:
              "Learn how to interact with Flare onchain and offchain.",
          },
          items: [
            {
              type: "autogenerated" as "autogenerated",
              dirName: "network/guides",
            },
          ],
        },
        {
          type: "category" as "category",
          label: "Network Reference",
          collapsed: true,
          link: { type: "doc", id: "network/solidity-reference" },
          items: [
            {
              type: "autogenerated" as "autogenerated",
              dirName: "network/solidity-reference",
            },
          ],
        },
        {
          type: "category" as "category",
          label: "Flare Systems Protocol",
          collapsed: true,
          link: { type: "doc", id: "network/fsp" },
          items: [
            {
              type: "doc" as "doc",
              label: "Protocol Components",
              link: { type: "doc", id: "network/fsp/protocol-components" },
            },
            {
              type: "doc" as "doc",
              label: "System Protocols",
              link: { type: "doc", id: "network/fsp/system-protocols" },
            },
            {
              type: "doc" as "doc",
              label: "Offchain Services",
              link: { type: "doc", id: "network/fsp/offchain-services" },
            },
            {
              type: "doc" as "doc",
              label: "Rewarding",
              link: { type: "doc", id: "network/fsp/rewarding" },
            },
            {
              type: "category" as "category",
              label: "FSP Reference",
              collapsed: true,
              link: { type: "doc", id: "network/fsp/solidity-reference" },
              items: [
                {
                  type: "autogenerated" as "autogenerated",
                  dirName: "network/fsp/solidity-reference",
                },
              ],
            },
          ],
        },
      ],
    },
  ],
};

const renderSidebarItems = (items: SidebarItem[]) => {
  return items.map((item, index) => (
    <Accordion.Item
      key={index}
      value={`item-${index}`}
      className={styles.accordionItem}
    >
      {/* Check if item has children (i.e., items property exists and has children) */}
      {item.items && item.items.length > 0 ? (
        <>
          <Accordion.Trigger className={styles.accordionTrigger}>
            {item.label}
            <ChevronDown className={styles.chevron} />
          </Accordion.Trigger>
          <Accordion.Content className={styles.accordionContent}>
            <Accordion.Root type="multiple">
              {renderSidebarItems(item.items)}{" "}
              {/* Recursive call to render child items */}
            </Accordion.Root>
          </Accordion.Content>
        </>
      ) : (
        // If no children, render the item as a simple link
        item.link &&
        item.link.type === "doc" && (
          <SidebarLink href={item.link.id || "#"} className={styles.link}>
            {item.label}
          </SidebarLink>
        )
      )}
    </Accordion.Item>
  ));
};

// Custom SidebarLink component for manual navigation
const SidebarLink: React.FC<SidebarLinkProps> = ({
  href,
  children,
  className,
}) => {
  const router = useRouter();

  // Handle link click event
  const handleClick = (e: React.MouseEvent<HTMLAnchorElement, MouseEvent>) => {
    e.preventDefault(); // Prevent default anchor behavior

    // Programmatically navigate to the link's destination
    router.push(href); // Use Next.js router to navigate to the desired path
  };

  return (
    <a href={href} className={className} onClick={handleClick}>
      {children}
    </a>
  );
};

const DocsNavigation: React.FC = () => {
  return (
    <aside className={styles.sidebar}>
      <div className={styles.sidebarHeader}>
        {/* Add search bar or other header elements here */}
      </div>
      <ScrollArea.Root className={styles.scrollArea}>
        <ScrollArea.Viewport>
          <nav className={styles.nav}>
            <Accordion.Root type="multiple">
              {sidebars.networkSidebar &&
                renderSidebarItems(sidebars.networkSidebar)}{" "}
              {/* Render the entire sidebar */}
            </Accordion.Root>
          </nav>
        </ScrollArea.Viewport>
        <ScrollArea.Scrollbar
          className={styles.scrollbar}
          orientation="vertical"
        >
          <ScrollArea.Thumb className={styles.thumb} />
        </ScrollArea.Scrollbar>
      </ScrollArea.Root>
    </aside>
  );
};

export default DocsNavigation;
